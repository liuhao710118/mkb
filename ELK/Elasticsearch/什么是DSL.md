## 什么是DSL

> DSL（Domain Specific Language）是 Elasticsearch 的 JSON 查询语言

特点：

- JSON 结构
- 可组合
- 支持全文检索 + 精确查询 + 聚合 + 排序



一个最基本的查询结构

```
GET logs_index/_search
{
  "query": {
    "match_all": {}
  }
}
```

完整的查询结构

```
{
  "query": {},        // 查询条件
  "from": 0,
  "size": 10,
  "sort": [],
  "_source": [],
  "aggs": {}
}

```



## 查询全部数据 match_all

`match_all`是 Elasticsearch 查询语言（DSL）中最简单直接的一个查询语句。它的作用就像它的名字一样：**匹配所有文档**，也就是把索引里的数据，不加任何条件地全部查出来。

### 💡 通俗的理解

你可以把 Elasticsearch 的索引想象成一个文件夹里的所有文件。

- **普通查询（如 `match`）**：就像你带着一个具体问题去文件夹里找文件，比如“找出所有提到‘项目报告’的文件”。这是在**筛选**文件。
- **`match_all`查询**：则像是你简单地说：“把文件夹里所有文件都给我列出来”。它不关心文件内容是什么，只是要**全部**文件。

因此，`match_all`通常用于需要获取索引中完整数据列表的场景，比如数据预览、统计总数或与其他操作结合使用。

### 🛠️ 如何使用

它的基本语法非常简单：

```
GET /你的索引名/_search
{
  "query": {
    "match_all": {}
  }
}
```

你还可以轻松地配合其他参数使用，例如：

- **限制返回数量与分页**：使用 `size`和 `from`参数。

```
{
  "query": { "match_all": {} },
  "size": 5,  // 只返回5条结果
  "from": 10  // 跳过前10条结果，常用于分页
}
```

- **排序**：使用 `sort`参数。

```
{
  "query": { "match_all": {} },
  "sort": [ { "create_date": { "order": "desc" } } ] // 按创建日期降序排列
}
```

- **选择返回字段**：使用 `_source`参数指定需要返回的字段。

```
{
  "query": { "match_all": {} },
  "_source": ["title", "create_date"] // 只返回标题和创建日期字段
}
```

### ⚠️ 注意事项

1. **默认返回数量**：出于性能考虑，Elasticsearch 默认不会一次性返回所有结果。即使使用 `match_all`，默认也只返回前 **10** 条记录。如果需要更多，必须通过 `size`参数明确指定。
2. **谨慎处理大数据集**：如果索引中有数百万甚至更多文档，直接使用 `match_all`获取全部数据会对集群性能造成巨大压力，甚至导致问题。对于深度分页（例如想获取第10000页之后的数据），不建议使用 `from`/`size`，而应考虑使用 `scroll`或 `search_after`等更高效的方式。

### 💎 总结

简单来说，`match_all`就是 Elasticsearch 里的“**全选**”操作。它是你进行条件筛选前的基础工具，非常适合用来快速查看数据概貌或测试连接。但在实际业务搜索中，你更常使用的会是像 `match`、`term`或 `bool`这样的条件查询。

希望这个解释对你有帮助！如果你想了解如何进行条件搜索，我很乐意为你介绍 `match`查询等其他 DSL 语句。





## 精确匹配 term

`term`是 Elasticsearch 中用于**精确值匹配**的查询，类似于数据库里的等值查询。下面这个表格能帮你快速抓住核心，了解它和 `match`查询的区别。

| 特性         | `term`查询                                           | `match`查询                                |
| ------------ | ---------------------------------------------------- | ------------------------------------------ |
| **查询方式** | **精确匹配**，不分析搜索词，直接匹配索引中的词项     | **全文检索**，会先分析搜索词，然后进行匹配 |
| **适用场景** | 数字、日期、标签等**结构化数据**（如商品ID、状态码） | 文章内容、描述等**非结构化文本**           |
| **通俗理解** | **身份证识别**：必须完全一致才算匹配                 | **搜索引擎**：意思相关即可，允许部分匹配   |

### 💡 字段类型是关键

使用 `term`查询时，要特别留意目标字段的类型（`text`还是 `keyword`），这直接决定查询字符串是否需要和字段被索引的方式完全一致。

- **`keyword`类型字段**：字段值会被当作一个完整的整体存储。用 `term`查询时，搜索词必须和文档中的值**完全一致**（包括大小写和空格）才能匹配。
- **`text`类型字段**：字段值会被分词器拆分成多个独立的词项（如"颐和园路5号"会被分成"颐"、"和"、"园"等）。此时，若用 `term`查询去搜索完整的"颐和园路5号"，反而无法匹配，但搜索单个分词如"颐"则可以匹配。对于 `text`字段，若要精确匹配完整内容，通常使用其内置的 `.keyword`子字段。

### 🛠️ 如何使用

基本语法如下，你需要在查询中指定字段名和要精确匹配的值：

```
GET /your_index/_search
{
  "query": {
    "term": {
      "author": {
        "value": "J.K.罗琳"
      }
    }
  }
}
```

简写形式可以是：

```
{
  "query": {
    "term": {
      "author": "J.K.罗琳"
    }
  }
}
```

如果需要同时匹配多个精确值，可以使用 `terms`查询：

```
{
  "query": {
    "terms": {
      "tags": ["小说", "科幻", "经典"]
    }
  }
}
```

### 💎 总结与实用建议

简单来说，`term`查询是 Elasticsearch 里的“**精确查找**”工具。

在实际应用中，你可以参考以下建议：

- **精确匹配**时（如状态、ID、标签），优先考虑 `term`查询。
- **全文搜索**时（如文章、描述），应使用 `match`查询。
- 对 `text`字段进行精确匹配时，记得使用 `.keyword`。



## 全文检索 分词匹配 match

简单来说，Elasticsearch 中的 `match`查询就像是搜索引擎里的**智能模糊搜索**。它不会要求文档必须一字不差地包含你的搜索词，而是试图理解你的意图，找出那些意思上相关的文档，并聪明地给更匹配的文档更高的排名。

为了让你快速抓住精髓，下面这个表格清晰地对比了 `match`查询和另一种常用查询 `term`的核心区别。

| 特性           | `match`查询 (智能模糊搜索)                 | `term`查询 (精确匹配)                            |
| -------------- | ------------------------------------------ | ------------------------------------------------ |
| **查询方式**   | **全文检索**，会先分析搜索词，然后进行匹配 | **精确匹配**，不分析搜索词，直接匹配索引中的词项 |
| **是否分词**   | ✅ 是，对查询内容进行分词                   | ❌ 否，直接查询确切值                             |
| **相关性评分** | ✅ 计算 `_score`，用于结果排序              | 通常不计算（用于过滤语境时）                     |
| **适用场景**   | 文章标题、内容描述等**非结构化文本**       | 商品ID、状态码、标签等**结构化数据**             |
| **通俗理解**   | **搜索引擎**：意思相关即可，允许部分匹配   | **身份证识别**：必须完全一致才算匹配             |

### 🔍 工作原理四步走

`match`查询的工作方式很像一个标准的搜索引擎流程：

1. **检查字段类型**：首先确认你要搜索的字段是否是支持分词的文本类型。
2. **分析查询字符串**：将你输入的搜索内容（例如“宝马多少马力”）交给**分析器** 处理。分析器通常会做分词、转小写、去除标点停用词等操作，最终得到一系列词项，如“宝马”、“多少”、“马力”。
3. **查找匹配文档**：用这些分好的词项，去倒排索引中查找包含其中任何一个或多个词项的文档。
4. **为每个文档评分**：根据复杂的算法计算相关性评分 `_score`。一个文档包含的搜索词越多、词频越合理、字段越短，得分通常就越高，排名也越靠前。

### ⚙️ 核心参数与用法

`match`查询的强大之处在于它提供了参数让你控制匹配的松紧程度。

| 参数                       | 作用                                                         | 示例说明                                                     |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`operator`**             | 控制分词后的逻辑关系。默认是 `or`，文档匹配任意一词即可；设为 `and`则要求文档必须包含所有词项。 | 搜索“宝马 马力”，`or`会返回包含“宝马”或“马力”的文档；`and`只返回同时包含两者的文档。 |
| **`minimum_should_match`** | 更灵活地控制匹配精度。可以指定一个最小匹配词项数或百分比。   | 搜索“quick brown dog”三个词，设置 `"75%"`（相当于至少匹配2个词），能平衡查全率和查准率。 |
| **`fuzziness`**            | 允许容错匹配，应对拼写错误。可以设置为一个可容忍的编辑距离。 | 搜索“john”，通过模糊匹配也可能找到“jon”或“jhon”的文档。      |

### 💡 实用建议

1. **字段类型是关键**：使用 `match`查询的字段通常应映射为 `text`类型，因为这类字段会被分词，适合全文搜索。如果你需要对一个字段同时进行全文搜索和精确匹配（如按产品名精确查询），可以在映射时为其同时设置 `text`类型和 `keyword`子字段。
2. **性能考量**：由于需要分词和计算相关性评分，`match`查询通常比作为过滤条件使用的 `term`查询开销更大。在需要进行频繁、严格的精确匹配或范围过滤时（如“状态为已发布”、“价格在100-200元之间”），可考虑使用 `filter`子句，因为它会缓存结果且不计算分数，效率更高。
3. **探索更多变体**：
   - **`match_phrase`**：用于精确匹配词组，词序和相对位置都需要符合要求。
   - **`multi_match`**：允许在多个字段中执行同一个 `match`查询。

Elasticsearch 的 `match`查询是进行全文搜索的首选工具，它懂得如何智能地处理文本。下面通过一个产品索引的例子，为你展示其核心用法。

### 📌 基础单字段匹配

最基本的用法是搜索单个字段。例如，在商品描述中查找包含 **"leather"** 或 **"jacket"** 的商品。由于 `operator`参数默认为 `or`，以下查询会匹配描述中出现任一词汇的商品。

```
GET /products/_search
{
  "query": {
    "match": {
      "description": "leather jacket"
    }
  }
}
```

### 🔍 控制匹配精度

当需要更精确的结果时，可以调整匹配规则。

- **要求包含所有词条**：使用 `"operator": "and"`，确保文档包含查询中的所有词汇。下面的查询要求文档必须同时包含 **"leather"**、**"jacket"**、**"winter"** 和 **"wear"** 才会被匹配。

```
GET /products/_search
{
  "query": {
    "match": {
      "description": {
        "query": "leather jacket winter wear",
        "operator": "and"
      }
    }
  }
}
```

- **灵活匹配词条数**：`minimum_should_match`参数更灵活，可以指定需要匹配的词条最小数量或百分比。例如，查询三个词时设置 `"75%"`（相当于至少匹配 `2`个），可以在查全率和查准率之间取得平衡。

```
GET /products/_search
{
  "query": {
    "match": {
      "description": {
        "query": "quick brown dog",
        "minimum_should_match": "75%"
      }
    }
  }
}
```

### ✨ 模糊匹配与高亮

`match`查询还能处理一些不精确的情况。

- **应对拼写错误**：通过 `fuzziness`参数开启模糊匹配，允许查询词与索引中的词存在一定差异（如拼写错误）。这可以找到类似 **"quik"** 或 **"quack"** 的文档。
- **高亮匹配内容**：使用 `highlight`功能，可以在返回结果中突出显示匹配到的关键词，提升用户体验。

```
GET /products/_search
{
  "query": {
    "match": {
      "description": "leather"
    }
  },
  "highlight": {
    "fields": {
      "description": {}
    }
  }
}
```

### ⚙️ 高级组合查询

在实际应用中，`match`查询经常与其他查询组合使用，构建复杂的搜索逻辑。例如，在 `bool`查询的 `must`子句中使用 `match`查询进行关键词搜索，同时在 `filter`子句中使用 `range`查询进行范围过滤（如价格、日期）。过滤器不影响相关性评分，但能高效地缩小结果集。

```
GET /products/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "description": "winter coat"
          }
        }
      ],
      "filter": [
        {
          "range": {
            "price": {
              "gte": 100,
              "lte": 300
            }
          }
        }
      ]
    }
  }
}
```

### 💎 核心要点速览

下表总结了 `match`查询的关键特性和适用场景，方便你快速回顾：

| 特性/场景    | 说明                                               | 常用参数值                             |
| ------------ | -------------------------------------------------- | -------------------------------------- |
| **全文搜索** | 对文本字段进行搜索，查询词会被分词。               | 默认行为                               |
| **匹配逻辑** | 控制词条间的逻辑关系。                             | `operator`: `or`（默认） / `and`       |
| **匹配精度** | 灵活控制需要匹配的词条数量。                       | `minimum_should_match`: 百分比或固定数 |
| **容错搜索** | 应对拼写错误或近似匹配。                           | `fuzziness`: 如 `"AUTO"`               |
| **结果排序** | 按相关性评分(`_score`)排序，更相关的文档排在前面。 | 自动计算                               |

`match`查询的强大之处在于它的智能和灵活。你可以根据具体的搜索需求，组合使用这些参数来精确控制搜索行为。

希望这些案例能帮助你更好地理解和使用 `match`查询。如果你对某个特定场景有更深入的疑问，或者想了解 `match_phrase`（短语匹配）等进阶用法，随时可以告诉我。



## 多字段搜索 multi_match

简单来说，Elasticsearch 里的 `multi_match`查询，就像是**一次派出多个侦察兵，到不同的区域去搜索同一个目标**。只要任何一个侦察兵在任何一个区域里找到了目标，就算成功。

它的核心作用就是**允许你同时在多个字段中搜索同一个关键词**。

### 💡 直观理解：多字段搜索

为了让你快速抓住精髓，下面这个表格对比了 `multi_match`和基础的 `match`查询。

| 特性           | `match`查询 (单兵侦察)                     | `multi_match`查询 (多路出击)                                 |
| -------------- | ------------------------------------------ | ------------------------------------------------------------ |
| **搜索字段数** | **一个**                                   | **多个**                                                     |
| **适用场景**   | 明确知道要在哪个字段（如“商品名称”）中搜索 | 不确定信息在哪个字段，需要在多个字段（如“商品名称”、“描述”、“品牌”）中广泛查找 |
| **性能影响**   | 对查询性能影响相对较小                     | 参与查询的字段越多，对查询性能的影响通常越大                 |
| **通俗比喻**   | 派一个侦察兵去一个指定地点搜索             | 同时派出多个侦察兵到多个可能的地点搜索                       |

### 🛠️ 如何使用

它的基本语法很简单，你只需要指定要搜索的**关键词**（`query`）和**目标字段列表**（`fields`）。

```
GET /indexName/_search
{
  "query": {
    "multi_match": {
      "query": "搜索关键词", 
      "fields": ["字段1", "字段2", "字段3"] 
    }
  }
}
```

你还可以通过 `^`符号来提升某个字段的权重。例如，下面的查询表示，在 `title`字段中找到的结果比在 `content`字段中找到的结果更重要，相关性得分会更高。

```
{
  "query": {
    "multi_match": {
      "query": "苹果",
      "fields": ["title^3", "content"] // `title`字段的权重是`content`字段的3倍
    }
  }
}
```

### ⚙️ 高级模式：`type`参数

`multi_match`的强大之处在于它的 `type`参数，这个参数决定了多个字段的搜索结果如何合并和评分。以下是几种常见的类型：

| 类型                     | 通俗解释                                                     | 适用场景                                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`best_fields`** (默认) | **赢家通吃**。只使用**得分最高**的那个字段的分数作为最终得分。 | 关键词很可能只在一个字段中出现，你只想找到那个最匹配的字段所在的文档。 |
| **`most_fields`**        | **票数取胜**。将所有匹配字段的**分数合并**起来作为最终得分。 | 文档的不同字段有不同分词方式，需要综合考量。                 |
| **`cross_fields`**       | **化零为整**。将多个字段视为一个**大字段**进行搜索，要求每个搜索词项至少在某个字段中出现。 | 需要跨字段匹配完整信息，比如同时搜索“姓名”和“地址”来找到一个完整的人名。 |



### `multi_match`查询在不同类型字段上的表现和特点



**`multi_match`查询主要设计用于 `text`字段，但它实际上可以用于任何类型的字段**。不过，其**核心价值和典型应用场景确实集中在 `text`字段的全文搜索上**。

下面这个表格帮你快速了解 `multi_match`查询在不同类型字段上的表现和特点。

| 字段类型          | `multi_match`查询行为特点                                    | 典型应用场景与说明                                           |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`text`字段**    | ✅ **最主要的使用场景**。查询词会先被分词，然后在多个指定字段中进行**全文检索**，计算相关性得分（`_score`）。 | 在文章的`title`、`content`、`abstract`等多个文本字段中搜索同一个关键词。 |
| **`keyword`字段** | ⚠️ **行为改变**。查询词**不会被分词**，进行的是**精确匹配**。通常需要查询词与字段值完全一致才能匹配。 | 比如，在商品的`tags`（标签）字段中精确查找包含特定标签的商品。但这种情况更常直接使用 `term`查询。 |
| **数值/日期字段** | ⚠️ **通常不适用**。虽然语法允许，但对数字或日期进行“多字段匹配”的实际业务意义不大。 | 对这些类型的精确查找或范围过滤，使用 `term`或 `range`查询更为清晰和高效。 |

### 💎 总结与实用建议

简单来说，`multi_match`就是你进行**广泛、模糊搜索**时的利器。

在实际应用中，你可以参考以下建议：

- **明确搜索目标时**：如果很清楚要找的内容在哪个字段，优先使用 `match`查询，效率更高。
- **需要广泛搜索时**：当不确定信息存在哪里，需要在多个字段中查找时，使用 `multi_match`。
- **提升查询性能**：如果经常需要多字段搜索，可以考虑使用 `copy_to`参数将这些字段的内容拷贝到一个新的组合字段中，然后只需对这个新字段进行 `match`查询，这通常比 `multi_match`性能更好。



