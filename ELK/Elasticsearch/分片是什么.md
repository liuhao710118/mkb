





## 一、什么是分片（Shard）

**分片是 Elasticsearch 中索引的最小数据单元**。
一个索引在逻辑上是完整的，但在物理上会被拆分成多个分片，分布在不同节点上。

👉 本质上：

> **一个分片 = 一个 Lucene 索引**

例如：

```text
index = logs-2026
primary shards = 3
replica shards = 1
```

最终会得到：

- 3 个主分片（Primary Shard）
- 3 个副本分片（Replica Shard）
- 总计 6 个分片

------

## 二、为什么需要分片

### 1️⃣ 支持海量数据存储

- 单机磁盘、内存、CPU 有上限
- 分片可以把数据**拆散到多台节点**

### 2️⃣ 提高查询和写入性能

- 查询可以在多个分片上**并行执行**
- 写入分散到多个主分片

### 3️⃣ 高可用（HA）

- 主分片损坏 → 副本分片顶上
- 节点宕机 → 数据仍可用

------

## 三、分片的类型

### 1️⃣ 主分片（Primary Shard）

- **数据写入的入口**
- 每个文档只属于某一个主分片
- **索引创建时确定，默认不可修改**

特点：

- 决定了索引的最大扩展能力
- 后期不能随意增加（7.x 之后可通过 split 有条件扩容）

------

### 2️⃣ 副本分片（Replica Shard）

- 主分片的拷贝
- 用于：
  - 高可用
  - 分担读请求

特点：

- 数量可以随时修改
- **不能和对应的主分片在同一个节点**

------

## 四、分片是如何工作的（写 & 查）

## 📥 写入流程

![Image](./assets/%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88/es_index_operations.png)

![Image](./assets/%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88/1YKqYMalqxOfwjjKkRd6fSg.png)

1. 客户端写入文档
2. ES 通过 **routing 算法（hash）** 决定写入哪个主分片
3. 主分片写入成功
4. 同步写入对应的副本分片
5. 返回成功

**路由公式（简化）**：

```text
shard = hash(_routing or _id) % primary_shards
```

------

## 🔍 查询流程

![Image](./assets/%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88/es-searching-data-flow.png)

![Image](./assets/%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88/1YKqYMalqxOfwjjKkRd6fSg.png)

1. 请求打到任意一个节点（协调节点）
2. 请求被 **scatter** 到所有相关分片
3. 各分片并行查询
4. 结果在协调节点 **gather + merge**
5. 返回最终结果

------

## 五、分片数量怎么设计（非常重要）

### ❌ 常见误区

- 分片越多越好 ❌
- 默认 5 个主分片 ❌（老版本习惯）

------

### ✅ 经验原则（7.x / 8.x）

### 1️⃣ 单个分片大小建议

| 场景         | 建议            |
| ------------ | --------------- |
| 日志、指标   | **20GB ~ 50GB** |
| 普通业务数据 | **10GB ~ 30GB** |
| 超大索引     | ≤ 50GB          |

------

### 2️⃣ 节点与分片关系

- 每个节点：
  - **不要超过 20~30 个活跃分片 / GB 堆内存**
- 8GB heap → ≤ 160~240 个分片

------

### 3️⃣ 索引创建示例

```json
PUT logs-2026-01
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1
  }
}
```

------

## 六、分片相关的常用操作

### 查看分片分布

```bash
GET _cat/shards?v
```

### 查看索引分片设置

```bash
GET logs-2026-01/_settings
```

### 动态调整副本数

```bash
PUT logs-2026-01/_settings
{
  "number_of_replicas": 2
}
```

------

## 七、进阶知识（你做运维会经常遇到）

### 🔹 分片状态

- `INITIALIZING`
- `STARTED`
- `RELOCATING`
- `UNASSIGNED` ⚠️

### 🔹 分片重分配（Rebalance）

- 节点加入 / 离开
- 集群负载不均
- 磁盘水位触发

------

## 八、一句话总结

> **分片是 Elasticsearch 实现“分布式 + 高性能 + 高可用”的核心机制**

- 主分片：决定容量
- 副本分片：决定可用性和读性能
- 分片不是越多越好，而是**刚刚好



# 下面都是来自deekseek的见解
------


Elasticsearch的分片（Shard）是它实现海量数据存储和高效处理的核心“魔法”。作为刚入门的伙伴，别担心，我会用尽可能通俗的方式，带你彻底搞懂它。

# 🌰 理解分片：从一个简单的比喻开始

想象一下，你有一个巨大的图书馆，里面存放着成千上万本书（也就是你的数据）。如果所有书都堆在一个房间里，找起来会非常困难。那么，你会怎么做呢？一个聪明的办法是：**把所有的书分类，然后放到多个相连的小房间里**。

在Elasticsearch里，这个“大图书馆”就是一个**索引**，而每个“小房间”就是一个**分片**。分片本质上是索引的一个数据子集，一个完整的索引可以由多个分片共同组成。

## 为什么要分片？—— 分片的核心价值

1. **突破存储限制**：单台机器的硬盘空间是有限的。通过分片，可以将TB级别的数据分布到集群的多台机器上，实现**水平扩展**。
2. **提升性能和吞吐量**：查询可以**并行**地在多个分片上同时执行，最后将结果合并。这就像让多个管理员同时在多个小房间里帮你找书，速度远快于一个人在大仓库里摸索。
3. **实现高可用性**：通过为分片创建副本，当某个分片所在的机器出现故障时，它的副本可以立即顶上，保证服务不中断，数据不丢失。

# 🔩 分片的两种角色：主分片与副本分片

在Elasticsearch中，分片有两种明确的角色分工，理解它们至关重要。

| 分片类型                     | 角色与职责                                                   | 特点                                                         | 类比                                                       |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| **主分片 (Primary Shard)**   | 数据的**原始**存储容器，**所有写操作（新增、更新、删除）都必须先在主分片上完成**。 | **数量不可变**：索引创建时通过 `number_of_shards`参数设定，之后**无法修改**。 | 图书馆的**原始藏书室**，所有新书都必须先放入这里。         |
| **副本分片 (Replica Shard)** | 主分片的**完整拷贝**（副本），主要提供**数据冗余**和**读请求的负载均衡**。 | **数量动态可变**：索引创建后，可以通过 `number_of_replicas`参数随时调整。 | 原始藏书室的**备份阅览室**，可供读者查阅，以防原始室关闭。 |

一个索引有3个主分片和1个副本分片，那么数据分布是这样的：

- **总分片数** = 3个主分片 + (3个主分片 * 1个副本) = 6个分片。
- **高可用**：即使丢失一个节点，只要每个主分片至少有一个副本在其他节点上存活，数据就是安全的。

# 🧠 分片如何工作：路由、写入与搜索

## 1. 文档如何找到自己的“家”（路由）

当你存入一个文档时，Elasticsearch如何知道该把它放到哪个主分片上呢？这依赖于一个简单的**路由算法**：

```
shard_id = hash(routing_value) % number_of_primary_shards
```

- **routing_value**：默认是文档的 `_id`字段，你也可以指定一个业务相关的字段（如用户ID）。
- 这个算法确保了**同一个routing值的文档，一定会被路由到同一个主分片**上。这也解释了为什么主分片数量一旦创建就不可变，因为数量一变，取模的结果就全乱了，文档就找不到了。

## 2. 近实时搜索：写入后如何快速被查到

这是一个非常重要的特性。新文档被索引后，并不是立即就能被搜索到，而是有约**1秒**的延迟。这是因为：

1. **写入内存与事务日志**：新文档先被写入内存缓冲区，同时追加到事务日志（Translog）中以保证数据安全。
2. **刷新**：默认每秒一次，内存缓冲区的内容会被生成一个**新的段**。这个段还在文件系统缓存中，未真正落盘，但此时已经被打开，使得文档**可被搜索**。这个过程叫做刷新（Refresh）。
3. **刷盘**：Translog会定期、累积到一定大小时，才会将段真正持久化到磁盘，并清空旧的Translog。这个过程叫刷盘（Flush）。

所以，Elasticsearch是**近实时（Near Real-Time, NRT）** 的，牺牲了一点实时性，换来了巨大的写入性能提升。

## 3. 段合并

每次刷新都会产生一个小段，段过多会消耗资源、影响搜索速度。Elasticsearch会在后台自动将多个小段合并成更大的段，并清除被标记删除的文档。

# 💡 作为新手，需要注意的关键点

1. **主分片数量要提前规划好**：这是最重要的一个决定，因为创建索引后就不能改了。如果设置不当，只能重建索引。
2. **合理控制分片大小**：分片不是越多越好。过小的分片会导致资源开销大；过大的分片则会影响恢复速度和稳定性。
   - **经验值**：通常建议单个分片大小控制在 **20GB 到 50GB** 之间。
   - **计算示例**：如果你预估一个索引最终有150GB数据，那么设置3到5个主分片是比较合适的。
3. **副本数量可根据需求动态调整**：初期为了节省资源，可以只设置1个副本甚至没有副本。当查询压力变大或对可用性要求提高时，再动态增加副本数。
4. **监控集群健康状态**：
   - **绿色（Green）**：所有主、副本分片均正常。
   - **黄色（Yellow）**：所有主分片正常，但部分副本分片缺失（例如，单节点集群）。
   - **红色（Red）**：有主分片丢失，数据已处于危险状态。

### 实践命令示例

你可以通过以下命令查看你集群中索引的分片分配情况：

```bash
# 查看所有索引的分片状态
GET _cat/indices?v

# 查看特定索引的分片详细分配
GET _cat/shards?index=your_index_name&v
```

